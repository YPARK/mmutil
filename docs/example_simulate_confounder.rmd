---
title: "Counterfactual Confounder Adjustment"
author: "Yongjin Park"
date: "`r Sys.time()`"
---

```{r include=FALSE}
library(tidyverse)
library(data.table)
library(patchwork)
library("R.utils")
source("Util-rmd.R")

fig.dir = 'Fig/example/simulation/'
dir.create(fig.dir, recursive = TRUE, showWarnings = FALSE)
knitr::opts_chunk$set(fig.path = fig.dir, fig.width = 4, fig.height = 3)
knitr::opts_chunk$set(dev.args = list(bg = "transparent"))
options(stringsAsFactors = FALSE)

.fread <- function(...) data.table::fread(..., header=FALSE)
```

```{r simulation_code, include=FALSE}
#' Random Normal
#' @param n1
#' @param n2
.rnorm <- function(n1, n2) {
  matrix(rnorm(n1 * n2), nrow = n1, ncol = n2)
}

#' Simulate GLM with multiple outcomes
#' @param nind number of individuals/samples
#' @param ncovar number of other covariates
#' @param ngenes number of genes/features
#' @param ncausal number of causal genes
simulate.glm <- function(nind, ncovar, ngenes, ncausal, confounded=FALSE) {

  if(ncovar > 0) {

    cc = .rnorm(nind, ncovar)
    W = .rnorm(nind, 1)

    if(confounded) {
      pr = sigmoid(cc %*% .rnorm(ncovar, 1) / sqrt(ncovar) + W)
    } else {
      pr = sigmoid(W)
    }

    ww = as.integer(runif(nind) < pr)
    xx = cbind(ww, cc)

  } else {

    W = .rnorm(nind, 1)
    pr = sigmoid(W)
    ww = as.integer(runif(nind) < pr)
    xx = ww

  }

  .beta = .rnorm(ncol(xx), ngenes) # effect size matrix
  causal = sample(ngenes, ncausal) # causal genes
  .beta[1, -causal] = 0            # no effect on the non-causal genes

  list(x = xx, beta = .beta, causal = causal)
}

#' Simulate sparse count matrix based on desgin matrix. The first
#' column contains phenotype information.
#' @param xx design matrix (individual x variable)
#' @param x.beta coefficients for xx
#' @param rho.a shape parameter for dispersion
#' @param rho.b rate parameter for dispersion
#' @param mu.a0 shape parameter for the mean model
#' @param ncell.ind number of cells per individual
simulate.data <- function(xx,
                          x.beta,
                          pve.1,
                          pve.c,
                          rho.a = 1.6,
                          rho.b = 2.0,
                          mu.nu = 1.,
                          ncell.ind = 500) {

  nind = nrow(xx)       # individual
  ngenes = ncol(x.beta) # genes
  ncovar = ncol(xx) - 1 # other covariates

  ln.mu.1 = xx[, 1, drop=FALSE] %*% x.beta[1, , drop=FALSE]
  .sd = apply(ln.mu.1, 2, sd)
  ln.mu.1[, .sd > 0] = scale(ln.mu.1[, .sd > 0], center=FALSE) * sqrt(pve.1)

  if(ncovar > 0) {
    ln.mu.c = scale(xx[, -1, drop=FALSE] %*% x.beta[-1, , drop=FALSE]) * sqrt(pve.c)
  } else {
    ln.mu.c = 0
  }

  .temp1 = scale(.rnorm(nind, ngenes)) * sqrt(1 - pve.1 - pve.c + 1e-8)
  .temp0 = scale(.rnorm(nind, ngenes)) * sqrt(1 - pve.c)

  ln.mu.0 = .temp0
  ln.mu.0[, .sd > 0] = .temp1[, .sd > 0]

  ln.mu = ln.mu.1 + ln.mu.c + ln.mu.0 # individuals x genes

  mu = exp(ln.mu) # individuals x genes
  nu = matrix(mu.nu, nrow=nrow(mu), ncol=1)
  lam = apply(mu, 2, function(x) rgamma(nind, shape = nu, scale = nu / x))
  
  ## sequencing depth for each cell
  rho = c()
  yy = c()
  ind.mem = c()
  cc.mem = c()
  
  for(ii in 1:nind) {
    .rho = rgamma(ncell.ind, shape=rho.a, scale=1/rho.b)
    .pois.rate = matrix(mu[ii, ], ncol=1) %*% matrix(.rho, nrow=1)
    .yy = apply(.pois.rate, 2, function(x) rpois(n=nrow(.pois.rate), lambda=x))
    yy = cbind(yy, .yy)

    rho = c(rho, .rho)
    ## individual membership
    ind.mem = c(ind.mem, rep(ii, ncell.ind))
    ## case-control annotation
    cc.mem = c(cc.mem, rep(round(xx[ii, 1]), ncell.ind))
  }

  yy = as.matrix(yy)

  ## remove empty column
  nnz = apply(yy > 0, 2, sum)
  .valid = which(nnz > 0)

  yy = yy[, .valid, drop = FALSE]
  rho = rho[.valid]
  cc.mem = cc.mem[.valid]
  ind.mem = ind.mem[.valid]
  
  list(y = yy, ind = ind.mem, cc = cc.mem, rho = rho, ln.mu = t(ln.mu), ln.mu.c = t(ln.mu.c))
}

write.data <- function(.glm, .data, .hdr) {
  y.sparse = Matrix::Matrix(.data$y, sparse=TRUE)

  .fwrite <- function(...) data.table::fwrite(..., col.names=FALSE, sep=" ")

  system(command = "rm -f " %&% .hdr %&% ".*")
  Matrix::writeMM(y.sparse, file=.hdr %&% ".mtx")
  system(command = "rm -f " %&% .hdr %&% ".mtx.gz*")
  system(command = "bgzip " %&% .hdr %&% ".mtx")

  .fwrite(as.data.table(.data$ind), file=.hdr %&% ".ind.gz")
  .fwrite(as.data.table(.data$cc), file=.hdr %&% ".trt.gz")

  .annot = data.table(V1 = 1:ncol(y.sparse), V2 = 0)
  .cols = .annot[, .(V1)]
  .lab = data.table(lab=0)

  .fwrite(.annot, file=.hdr %&% ".annot.gz")
  .fwrite(.cols, file=.hdr %&% ".cols.gz")
  .fwrite(.lab, file=.hdr %&% ".lab.gz")
}
```


## Simulate single-cell data matrix

$$
f(y) = \frac{\beta^{\alpha}}{\Gamma(\alpha)} y^{\alpha-1} e^{-y\beta}
$$

Letting $\mu = \alpha/\beta$ and $\nu = \alpha$

$$
f(y) = \frac{\nu^{\nu}}{\mu(\nu)} \mu^{-\nu} y^{\nu-1} e^{-y \nu / \mu}
$$

$$
f(y) = \exp\left\{ - (\nu/\mu) y + (\nu - 1) \ln y - \nu \ln \mu + \nu \ln \nu - \ln \mu(\nu) \right\}
$$

* $\rho_{j} \sim \mathsf{Gamma}(a_{\rho}, b_{\rho})$, which corresponds to a sequencing depth

* $\lambda_{gi} \sim \mathsf{Gamma}(\nu_{gi}, \nu_{gi} / \mu_{gi}))$ where $\ln \mu_{gi} = \sum_{k} X_{ik}\beta_{kg}$

* $Y_{gj} \sim \mathsf{Poisson}(\lambda_{gi} \rho_{j})$

By integrating out $\lambda$, we derive the following negative binomial model:

$$
\int d\lambda p(Y_{gj}|\lambda, \rho_{j}) p(\lambda|\nu_{g}, \mu_{gi}) =
\frac{\Gamma(Y_{gj} + \nu_{g})}{\Gamma(Y_{gj} + 1) \Gamma(\nu_{g})}
\left( \frac{\mu_{gi} \rho_{j}}{\mu_{gi} \rho_{j} + \nu_{g}} \right)^{Y_{gj}}
\left( \frac{\nu_{g}}{\mu_{gi} \rho_{j} + \nu_{g}} \right)^{\nu_{g}}
$$



## Results


### Testing the accuracy of individual-level aggregate effect estimation

```{r}
## Testing on the null data
set.seed(1)
exp.hdr = "example/simulation/confounder/exp1"
dir.create(dirname(exp.hdr), recursive=TRUE, showWarnings=FALSE)

temp.file = exp.hdr %&% ".rdata"
if(!file.exists(temp.file)) {
  .glm = simulate.glm(nind = 20,
                      ncovar = 0,
                      ngenes = 10000,
                      ncausal = 10)

  .data = simulate.data(xx = .glm$x,
                        x.beta = .glm$beta,
                        pve.1 = .0,
                        pve.c = .0,
                        ncell.ind = 100)
  save(.glm, .data, file=temp.file)
} else {
  load(file=temp.file)
}

mtx.file = exp.hdr %&% ".mtx.gz"
if(!file.exists(mtx.file)) {
  write.data(.glm, .data, exp.hdr)
}
```

```{sh}
[ -f example/simulation/confounder/out_exp1.mean.gz ] || 
	../src/mmutil_aggregate_col \
		--mtx example/simulation/confounder/exp1.mtx.gz \
		--col example/simulation/confounder/exp1.cols.gz \
		--annot example/simulation/confounder/exp1.annot.gz \
		--lab example/simulation/confounder/exp1.lab.gz \
		--ind example/simulation/confounder/exp1.ind.gz \
 		--out example/simulation/confounder/out_exp1

```


```{r Fig_Sim_Exp1}
r.hdr = gsub("exp", "out_exp", exp.hdr)

.mean = .fread(r.hdr %&% ".mean.gz")
.mu = .fread(r.hdr %&% ".mu.gz") %>%  log
.rho = .fread(r.hdr %&% ".rho.gz") %>% unlist

.dt = data.table(rho.true = .data$rho, rho.hat = .rho)

p1 = .gg.plot(.dt, aes(x=rho.true, y=rho.hat)) +
  geom_point(size=.5) +
  geom_abline(slope=1, colour="red") +
  ggtitle(.cor.str(.dt$rho.true, .dt$rho.hat))

.mu.true = as.data.table(.data$ln.mu)

.dt = tibble(ln.mu.true = .mu.true$V1, ln.mu.hat = .mu$V1) %>%
  filter(ln.mu.hat >  -5)

p2 = .gg.plot(.dt, aes(x=ln.mu.true, y=ln.mu.hat)) +
  geom_point(size=.5) +
  geom_abline(slope=1, colour="red") +
  ggtitle(.cor.str(.dt$ln.mu.true, .dt$ln.mu.hat))

p1 | p2
```


### Simulate case-control data matrix


```{r}
set.seed(1)
exp.hdr = "example/simulation/confounder/exp2"
dir.create(dirname(exp.hdr), recursive=TRUE, showWarnings=FALSE)

temp.file = exp.hdr %&% ".rdata"
if(!file.exists(temp.file)) {
  .glm = simulate.glm(nind = 100,
                      ncovar = 5,
                      ngenes = 1000,
                      ncausal = 10,
                      confounded = FALSE)

  .data = simulate.data(xx = .glm$x,
                        x.beta = .glm$beta,
                        pve.1 = .2,
                        pve.c = .5,
                        ncell.ind = 100)
  save(.glm, .data, file=temp.file)
} else {
  load(file=temp.file)
}

mtx.file = exp.hdr %&% ".mtx.gz"
if(!file.exists(mtx.file)) {
  write.data(.glm, .data, exp.hdr)
}
```



```{sh}
[ -f example/simulation/confounder/naive_exp2.mean.gz ] || 
	../src/mmutil_aggregate_col \
		--mtx example/simulation/confounder/exp2.mtx.gz \
		--col example/simulation/confounder/exp2.cols.gz \
		--annot example/simulation/confounder/exp2.annot.gz \
		--lab example/simulation/confounder/exp2.lab.gz \
		--ind example/simulation/confounder/exp2.ind.gz \
 		--out example/simulation/confounder/naive_exp2
```


```{sh}
#[ -f example/simulation/confounder/cfa_exp2.mean.gz ] || 
	../src/mmutil_cfa_col \
		--mtx example/simulation/confounder/exp2.mtx.gz \
		--col example/simulation/confounder/exp2.cols.gz \
		--annot example/simulation/confounder/exp2.annot.gz \
		--lab example/simulation/confounder/exp2.lab.gz \
		--ind example/simulation/confounder/exp2.ind.gz \
		--trt_ind example/simulation/confounder/exp2.trt.gz \
 		--out example/simulation/confounder/cfa_exp2

```





```{r}

r.hdr = gsub("exp", "cfa_exp", exp.hdr)
causal.genes = .glm$causal
label = .glm$x[, 1]

mu.obs = .fread(r.hdr %&% ".obs_mu.gz") %>% as.matrix
se.obs = .fread(r.hdr %&% ".obs_mu_sd.gz") %>% as.matrix

mu.cf = .fread(r.hdr %&% ".cf_mu.gz") %>% as.matrix
se.cf = .fread(r.hdr %&% ".cf_mu_sd.gz") %>% as.matrix

mu.r = .fread(r.hdr %&% ".resid_mu.gz") %>% as.matrix
se.r = .fread(r.hdr %&% ".resid_mu_sd.gz") %>% as.matrix

mu.r0 = .fread(r.hdr %&% ".resid_null_mu.gz") %>% as.matrix
se.r0 = .fread(r.hdr %&% ".resid_null_mu_sd.gz") %>% as.matrix

g = causal.genes[1]

g = 713

o = order(label)
plot(mu.obs[g, o], log="y", col="gray20", cex=.2)
points(mu.cf[g, o], col="gray", cex=.2)
points(mu.r[g, o], col=3, pch=19)
points(mu.r0[g, o], col=4, pch="+")

par(mfrow=c(1,2))
plot(mu.r[g, label ==1], mu.r0[g, label == 1]); abline(a=0, b=1, col=2)
plot(mu.r[g, label !=1], mu.r0[g, label != 1]); abline(a=0, b=1, col=2)

x = mu.r[g, label == 1] %>% log
y = mu.r0[g, label == 1] %>% log

t.test(x, y)

x = mu.r[g, label != 1] %>% log
y = mu.r0[g, label != 1] %>% log

t.test(x, y)



fit.glm <- function(xx, y, reg = 1) {
  p = ncol(xx)
  beta = rep(0, p)
  beta.se = rep(sqrt(reg), p)
  eta = xx %*% beta

  llik = 0
  
  for(iter in 1:100) {

    llik.old = llik

    y.pseudo = -1 + eta + exp(-eta) * y
    ww = exp(eta)

    for(j in 1:p) {
      .r = eta - xx[, j] * beta[j]
      .num = sum(ww * xx[, j] * (y.pseudo - .r))
      .denom = sum(ww * xx[, j]^2) + reg
      beta[j] = .num / .denom
      beta.se[j] = 1 / sqrt(sum(ww * xx[, j]^2))
      eta = .r + xx[, j] * beta[j]      
    }

    llik = mean(y * eta - exp(eta))
    if(abs(llik.old - llik) / abs(llik.old + 1e-4) < 1e-4){
      break
    }
  }

  list(beta = beta, se = beta.se)
}

rr = matrix(nrow=nrow(mu.obs), ncol=ncol(mu.obs))

for(j in 1:ncol(rr)) {

  xx = cbind(log(mu.cf[, j]), 1)
  y = matrix(mu.obs[, j])

  .out = fit.glm(xx, y)
  rr[, j] = log(y) - xx[, 1] * .out$beta[1] - .out$beta[2]
}

rr = scale(t(rr)) %>% t

pv0 = sapply(1:1000, function(g) wilcox.test(mu.obs[g, label==1], mu.obs[g, label!=1])$p.value)

pv1 = sapply(1:1000, function(g) wilcox.test(mu.obs[g, label==1], mu.cf[g, label==1])$p.value)

plot(-log10(pv0), -log10(pv1))
points(-log10(pv0[causal.genes]), -log10(pv1[causal.genes]), pch=19, cex=.5, col=2)

pv = sapply(1:1000, function(g) wilcox.test(rr[g, label==1], rr[g, label!=1])$p.value)

.svd = rsvd::rsvd(rr, k=4)

par(mfrow=c(1,3))

plot(.svd$v[, 1], .svd$v[, 2], xlab="PC1", ylab="PC2")
points(.svd$v[label==1, 1], .svd$v[label==1, 2], pch=19)

plot(.svd$v[, 2], .svd$v[, 3], xlab="PC2", ylab="PC3")
points(.svd$v[label==1, 2], .svd$v[label==1, 3], pch=19)

plot(.svd$v[, 3], .svd$v[, 4], xlab="PC3", ylab="PC4")
points(.svd$v[label==1, 3], .svd$v[label==1, 4], pch=19)



g = causal.genes[10]

g = 1

par(mfrow=c(2,2))

boxplot(.data$ln.mu[g, label==1], .data$ln.mu[g, label!=1])

boxplot(.data$ln.mu.c[g, label==1], .data$ln.mu.c[g, label!=1])

boxplot(mu.cf[g, label==1], mu.cf[g, label!=1], log="y")


plot(mu.cf[, 1], .data$ln.mu.c[,1], log="x")


################################################################

pv.best = sapply(1:1000,
       function(g) {
         y = .data$ln.mu[g, ]
         x = .data$ln.mu.c[g, ]
         w = .glm$x[, 1]
         summary(lm(y ~ x + w))$coefficients['w', 4]
       })

pv.2 = sapply(1:1000,
       function(g) {
         y = lm(log(mu.obs[g, ]) ~ .svd$v) %>% residuals
         x = log(mu.cf[g, ])
         w = .glm$x[, 1]
         summary(lm(y ~ x + w))$coefficients['w', 4]
       })


ate = sapply(1:1000,
             function(g) {
               w = .glm$x[, 1]
               cc = log(mu.cf[g, ])
               pr = glm(w ~ cc, family="binomial") %>% fitted
               
               y1 = mean(log(mu.obs[g, label == 1]) / pr[label==1])
               y0 = mean(log(mu.obs[g, label != 1]) / (1 - pr[label!=1]))
               y1 - y0
             })


par(mfrow=c(2,2))

plot(-log10(pv.best), -log10(pv0))
points(-log10(pv.best)[causal.genes], -log10(pv0)[causal.genes], pch=19)
abline(a=0,b=1,col=2)

plot(-log10(pv.best), -log10(pv))
points(-log10(pv.best)[causal.genes], -log10(pv)[causal.genes], pch=19)
abline(a=0,b=1,col=2)

plot(-log10(pv.best), -log10(pv.2))
points(-log10(pv.best)[causal.genes], -log10(pv.2)[causal.genes], pch=19)
abline(a=0,b=1,col=2)

## qqnorm(ate)
## abline(a=0,b=1,col=2)

plot(-log10(pv), ate)
points(-log10(pv)[causal.genes], ate[causal.genes], pch=19)
abline(a=0,b=1,col=2)



summary(lm(y ~ w))





################################################################


x11()
plot(as.numeric(mu.cf), as.numeric(.data$ln.mu.c), log="x")



plot(.data$ln.mu[g, ], mu.cf[g, ], log="y")

plot(.data$ln.mu[g, ], mu.obs[g, ], log="y")

plot(.data$ln.mu[g, ], mu.obs[g, ]/mu.cf[g, ], log="y")



hist(pv)
hist(pv0)

pv[causal.genes]
pv0[causal.genes]

plot(-log10(pv0), -log10(pv))
points(-log10(pv0[causal.genes]), -log10(pv[causal.genes]), pch=19, col=2)
abline(a=0,b=1,col=2)


plot(log(mu.obs[g, label==1]) - xx[,1] * .out$beta[1])
abline(h=0,col=2)


.temp = sapply(1:1000, function(g) {
  xx = cbind(log(mu.cf[g, label==1]), 1)
  y = mu.obs[g, label==1]
  .out = fit.glm(xx, y)
  c(.out$beta[2], .out$se[2])
})

.ash = ashr::ash(.temp[1, ], .temp[2, ])

.ash$result[causal.genes,]



z = sapply(1:1000, function(g) {
  xx = cbind(rr[g, label==1], 1)
  y = exp(rr[g, label==1])
  .out = fit.glm(xx, y)
  .out$beta[2] / .out$se[2]
})

plot(z)
points(causal.genes, z[causal.genes], col=2, pch=19)

z0 = sapply(1:1000, function(g) {
  xx = cbind(rr[g, label!=1], 1)
  y = exp(rr[g, label!=1])
  .out = fit.glm(xx, y)
  .out$beta[2] / .out$se[2]
})

plot(z0)
points(causal.genes, z0[causal.genes], col=2, pch=19)




o = order(z)
z0 = qnorm((1:1000)/1001)

plot(z0, z[o])




################################################################
TODO



x = log(mu.cf[g, label==1])
xx = cbind(x, 1)

.lm = glm(y ~ x, family="poisson")
summary(.lm)



points(causal.genes, residuals(.lm)[causal.genes], col=2, pch=19)




boxplot(as.numeric(mu.adj[, label==1]),
        as.numeric(mu.adj[, label!=1]))

t.test(as.numeric(mu.adj[, label==1]),
        as.numeric(mu.adj[, label!=1]))



Y = preprocessCore::normalize.quantiles(mu.obs)
Y.cf = preprocessCore::normalize.quantiles(mu.cf)

.svd = rsvd::rsvd(Y, k=3)
.svd.cf = rsvd::rsvd(Y.cf, k=3)

R = cor(.glm$x, .svd$v)
Matrix::image(Matrix::Matrix(R))

R.cf = cor(.glm$x, .svd.cf$v)
Matrix::image(Matrix::Matrix(R.cf))



Y.rr = lm(t(Y) ~ .svd.cf$v) %>% residuals %>% t

rho.obs = .fread(r.hdr %&% ".rho.gz") %>% as.matrix

.test.0 =
  lapply(1:ngene, function(g) {
    x = log(1 + mu.obs[g, label==1])
    y = log(1 + mu.obs[g, label!=1])
    t.test(x, y)
    })

pv.0 = sapply(.test.0, function(x) x$p.value)

.test.1 =
  lapply(1:ngene, function(g) {
    x = log(1 + Y.rr[g, label==1])
    y = log(1 + Y.rr[g, label!=1])
    t.test(x, y)
    })

pv.1 = sapply(.test.1, function(x) x$p.value)

qqplot(-log10(pv.0), -log10(pv.1))
abline(a=0, b=1, col=2)



TODO


g = which.min(pv.1)

.lm = lm(log(mu.obs[g, ]) ~ log(mu.cf[g, ]) + 1)

.yhat = predict(.lm)

boxplot(log(mu.obs[g, label==1]), .yhat[label==1])

plot(log(mu.obs[g, label==1]), .yhat[label==1])


boxplot(.lm$residuals[label==1], .lm$residuals[label!=1])

t.test(.lm$residuals[label==1])

t.test(.lm$residuals[label!=1])

boxplot(mu.obs[g, label==1], mu.obs[g, label!=1], log="y")

boxplot(mu.cf[g, label==1], mu.cf[g, label!=1], log="y")




boxplot(rr[2, label==1], rr[2, label=-1])

mu.obs = mu.obs / mean(mu.obs)
mu.cf = mu.cf / mean(mu.cf)


## plot(mu.cf[, 1], mu.adj[, 1])
## plot(mu.cf[, 1], mu.obs[, 1])

ngenes = nrow(mu.obs)

t.test.out =
  lapply(1:ngene, function(g) {
    x = log(1 + mu.obs[g, label==1])
    y = log(1 + mu.cf[g, label==1]) * .88
    t.test(x, y)
    })

pv = sapply(t.test.out, function(x) x$p.value)

x = -log10((1:ngenes)/(ngenes+1)); y= -log10(sort(pv))
plot(x, y)
abline(a=0,b=1,col=2)


w.test.out =
  lapply(1:ngene, function(g) {
    x = mu.obs[g, label==1]
    y = mu.cf[g, label==1]
    wilcox.test(x, y)
    })

## pv = sapply(w.test.out, function(x) x$p.value)

hist(pv)





.temp.adj = cor(t(mu.adj), label)

.temp.cf = cor(t(mu.cf), label)

.temp.naive = cor(t(mu.obs), label)

par(mfrow=c(1,2))

plot(.temp.naive, .temp.adj)
points(.temp.naive[causal.genes], .temp.adj[causal.genes], col="red", pch=19)
abline(a=0, b=1, col=3)

plot(.temp.naive, .temp.cf)
points(.temp.naive[causal.genes], .temp.cf[causal.genes], col="red", pch=19)
abline(a=0, b=1, col=3)


g = causal.genes[1]

g = 127

t.test(c(mu.obs[g, label==1], mu.cf[g, label!=1]),
       c(mu.cf[g, label==1], mu.obs[g, label!=1]),
       paired=TRUE)

wilcox.test(c(mu.obs[g, label==1], mu.cf[g, label!=1]),
            c(mu.cf[g, label==1], mu.obs[g, label!=1]))


plot(1:100, c(mu.obs[g, label==1], mu.cf[g, label!=1]), log="y")
points(1:100, c(mu.cf[g, label==1], mu.obs[g, label!=1]), pch = 19)

t.test(mu.adj[g, label==1], mu.adj[g, label!=1])



g = 133

mean(log(mu.obs[g, label == 1] / mu.cf[g, label == 1]))

mean(log(mu.cf[g, label == -1] / mu.obs[g, label == -1]))



## for(g in causal.genes)

g = causal.genes[2]

##
g = 10

x = mu.adj[g, label==1]
y = mu.adj[g, label!=1]

x0 = mu.obs[g, label==1]
y0 = mu.obs[g, label!=1]

x.c = mu.cf[g, label==1]
y.c = mu.cf[g, label!=1]


rr = lm(mu.obs[g, ] ~ mu.cf[g, ]) %>% residuals

x.r = rr[label==1]
y.r = rr[label!=1]

par(mfrow=c(1,3))

wilcox.test(x, y)

boxplot(log(1 + x), log(1 + y))

wilcox.test(x.r, y.r)

boxplot(x.r, y.r)

wilcox.test(x0, y0)

boxplot(log(1 + x0), log(1 + y0))


```





```{r}

r.hdr = gsub("exp", "naive_exp", exp.hdr)
causal.genes = .glm$causal
label = .glm$x[, 1]

mu.vanilla = .fread(r.hdr %&% ".mu.gz")

.temp.0 = cor(t(mu.vanilla), label)

.temp.0[causal.genes]


```




```{r}

## rho.true = .data$rho
## rho = unlist(fread("temp2.rho.gz"))
## mu = as.matrix(fread("temp2.mu.gz"))

## plot(log(mu[, 1]/10), .data$ln.mu[1, ]); abline(a=0, b=1, col=2)

## plot(log(mu[, 11]/10), .data$ln.mu[11, ]); abline(a=0, b=1, col=2)

## plot(rho, rho.true)

## mu.0 = apply(.data$y, 2, mean)

## plot(mu.0, rho.true)

## plot(log(mu.0), rho)


```



```{sh}

# ../src/mmutil_cfa_col \
# 	--mtx temp.mtx.gz \
# 	--col temp.cols.gz \
# 	--annot temp.annot.gz \
# 	--lab temp.lab.gz \
# 	--ind temp.ind.gz \
# 	--trt_ind temp.trt.gz \
# 	--log_scale --knn 10 \
# 	--out temp3


```


```{r}



## rho.2 = as.matrix(fread("temp3.rho.gz"))


## mu.hat = log(1 + as.matrix(fread("temp2.mu.gz")))
## adj.hat = log(1 + as.matrix(fread("temp3.adj_mu.gz")))
## cf.hat = log(1 + as.matrix(fread("temp3.cf_mu.gz")))
## mean.hat = as.matrix(fread("temp2.mean.gz"))

## mu.true = t(.glm$x[, 1, drop=F] %*% .glm$beta[1, , drop=F])

## causal = .glm$causal
## .case = which(.glm$x[, 1] > 0) 
## wilcox.test(adj.hat[g, .case], adj.hat[g, -.case])

## pv = apply(t(mean.hat), 2, function(x) wilcox.test(x[.case], x[-.case])$p.value)
## pv.a = apply(t(adj.hat), 2, function(x) wilcox.test(x[.case], x[-.case])$p.value)

## pv[.glm$causal]
## pv.a[.glm$causal]

## nn = nrow(mu.hat)
## nc = setdiff(1:nn, .glm$causal)

## g = nc[which.min(pv[-.glm$causal])]

## par(mfrow=c(2,1))
## plot(-log10(pv))
## points(causal, -log10(pv[causal]), col=2, pch=19)

## plot(-log10(pv.a))
## points(causal, -log10(pv.a[causal]), col=2, pch=19)

## par(mfrow=c(1,4))
## ##boxplot(mean.hat[g, .case], mean.hat[g, -.case], main="marginal")
## boxplot(mu.hat[g, .case], mu.hat[g, -.case], main="marginal")
## boxplot(adj.hat[g, .case], adj.hat[g, -.case], main="adjusted")
## boxplot(cf.hat[g, .case], cf.hat[g, -.case], main="couterfactual")
## boxplot(mu.true[g, .case], mu.true[g, -.case], main="true")

## plot(mu.hat[, 1], adj.hat[, 1])

## plot(mu.hat[, 73], adj.hat[, 73])

## plot(adj.hat[, 73], cf.hat[, 73])


## plot(mean.hat[, 1], mu.hat[, 1])

```



```{sh}

# TODO: just aggregate the count matrix to show that




```



```{sh}

# TODO: can CFA help?

#../src/mmutil_cfa_col  -h || exit 0

```


